<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>3D Cube MVP â€“ Orientation + Picking</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
<style>html,body{margin:0;background:#111}</style>
</head>
<body>
<script>
const GRID = 5;
const CELL = 80;
const CUBE = CELL * 0.85;
const DRAG_THRESHOLD = 20;
const PICK_RADIUS = 45;

const COLORS = {
  red:[255,60,60], green:[60,220,140], blue:[60,140,220],
  yellow:[255,240,60], white:[240,240,250], orange:[255,165,0]
};

const ROLL = {
  north:o=>({ top:o.south, bottom:o.north, north:o.top,    south:o.bottom, east:o.east, west:o.west }),
  south:o=>({ top:o.north, bottom:o.south, north:o.bottom, south:o.top,    east:o.east, west:o.west }),
  east: o=>({ top:o.west,  bottom:o.east,  east:o.top,     west:o.bottom,  north:o.north, south:o.south }),
  west: o=>({ top:o.east,  bottom:o.west,  east:o.bottom,  west:o.top,     north:o.north, south:o.south })
};

function freshOrientation(){
  return { top:'white', bottom:'yellow', north:'green', south:'blue', east:'red', west:'orange' };
}

let cubes = [
  { id:1, x:1, y:1, o:freshOrientation() },
  { id:2, x:3, y:1, o:freshOrientation() },
  { id:3, x:2, y:3, o:freshOrientation() }
];

let activeCube = null;
let dragging = false;
let dragDX = 0, dragDY = 0;

function inside(x,y){ return x>=0 && x<GRID && y>=0 && y<GRID; }
function occupied(x,y,ignore=null){ return cubes.some(c=>c!==ignore && c.x===x && c.y===y); }

function world(x,y){
  const r = GRID * CELL / 2;
  return [-r + CELL/2 + x*CELL, -r + CELL/2 + y*CELL];
}

/* ---- projection helper (no screenPosition required) ---- */
function project(p, x, y, z){
  // 1) if available, use it
  if (typeof p.screenPosition === "function") {
    const v = p.screenPosition(x,y,z);
    return { x:v.x, y:v.y };
  }

  // 2) use internal WEBGL matrices (works in many p5 versions)
  const r = p._renderer;
  if (r && r.uMVMatrix && r.uPMatrix && r.uMVMatrix.mat4 && r.uPMatrix.mat4) {
    const mv = r.uMVMatrix.mat4;
    const pr = r.uPMatrix.mat4;

    // multiply vec4 by mat4
    const mul = (m, v) => ([
      m[0]*v[0] + m[4]*v[1] + m[8]*v[2]  + m[12]*v[3],
      m[1]*v[0] + m[5]*v[1] + m[9]*v[2]  + m[13]*v[3],
      m[2]*v[0] + m[6]*v[1] + m[10]*v[2] + m[14]*v[3],
      m[3]*v[0] + m[7]*v[1] + m[11]*v[2] + m[15]*v[3],
    ]);

    const v = [x,y,z,1];
    const eye = mul(mv, v);
    const clip = mul(pr, eye);
    const w = clip[3] || 1e-9;
    const ndcX = clip[0]/w;
    const ndcY = clip[1]/w;

    return {
      x: (ndcX * 0.5 + 0.5) * p.width,
      y: (-ndcY * 0.5 + 0.5) * p.height
    };
  }

  // 3) last-resort fallback (still OK for near-orthographic feel)
  return { x: p.width/2 + x, y: p.height/2 + y };
}

function pickCube(p){
  let best=null, bestD=PICK_RADIUS;
  for(const c of cubes){
    const [wx,wy]=world(c.x,c.y);
    const wz=CUBE/2;
    const s = project(p, wx, wy, wz);
    const d = Math.hypot(p.mouseX - s.x, p.mouseY - s.y);
    if(d < bestD){ bestD=d; best=c; }
  }
  return best;
}

function quad(p,a,b,c,d,col){
  p.noStroke();
  p.fill(...COLORS[col]);
  p.beginShape();
  p.vertex(...a); p.vertex(...b); p.vertex(...c); p.vertex(...d);
  p.endShape(p.CLOSE);
}

function drawCube(p,o){
  const h=CUBE/2;
  const p000=[-h,-h,-h], p001=[-h,-h, h], p010=[-h, h,-h], p011=[-h, h, h];
  const p100=[ h,-h,-h], p101=[ h,-h, h], p110=[ h, h,-h], p111=[ h, h, h];

  quad(p, p001,p101,p111,p011, o.top);
  quad(p, p000,p010,p110,p100, o.bottom);
  quad(p, p011,p111,p110,p010, o.south);
  quad(p, p000,p100,p101,p001, o.north);
  quad(p, p101,p100,p110,p111, o.east);
  quad(p, p000,p001,p011,p010, o.west);
}

new p5(p=>{
  p.setup=()=>p.createCanvas(window.innerWidth, window.innerHeight, p.WEBGL);

  p.draw=()=>{
    p.background(20);
    p.ambientLight(90);
    p.directionalLight(220,220,220, 0.3,0.6,-1);

    const r=GRID*CELL/2;
    p.stroke(160); p.noFill();
    for(let i=0;i<=GRID;i++){
      const t=-r+i*CELL;
      p.line(t,-r,0,t,r,0);
      p.line(-r,t,0,r,t,0);
    }

    for(const c of cubes){
      const [cx,cy]=world(c.x,c.y);
      p.push();
      p.translate(cx,cy,CUBE/2);
      drawCube(p,c.o);
      p.pop();
    }

    if(dragging){
      p.resetMatrix();
      p.translate(-p.width/2,-p.height/2);
      p.stroke(255);
      p.line(p.mouseX-dragDX, p.mouseY-dragDY, p.mouseX, p.mouseY);
    }
  };

  p.mousePressed=()=>{
    activeCube = pickCube(p);
    dragging = true;
    dragDX = dragDY = 0;
  };

  p.mouseDragged=()=>{
    if(!dragging) return;
    dragDX += p.movedX;
    dragDY += p.movedY;
  };

  p.mouseReleased=()=>{
    if(!dragging) return;
    dragging = false;
    if(!activeCube) return;
    if(Math.hypot(dragDX,dragDY) < DRAG_THRESHOLD) return;

    const dir =
      Math.abs(dragDX) > Math.abs(dragDY)
        ? (dragDX>0?'east':'west')
        : (dragDY>0?'south':'north');

    const nx = activeCube.x + (dir==='east') - (dir==='west');
    const ny = activeCube.y + (dir==='south') - (dir==='north');
    if(!inside(nx,ny) || occupied(nx,ny,activeCube)) return;

    activeCube.x = nx;
    activeCube.y = ny;
    activeCube.o = ROLL[dir](activeCube.o);
  };

  p.windowResized=()=>p.resizeCanvas(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>