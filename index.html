<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Cube Roll â€“ Matrix MVP (Stable)</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
<style>
html,body{margin:0;overflow:hidden;background:#111;}
</style>
</head>
<body>
<script>
/* =====================
   Parameters
===================== */
const GRID = 5;
const CELL = 80;
const CUBE = CELL * 0.85;
const DRAG_THRESHOLD = 20;
const ANIM_MS = 250;

/* =====================
   Colors + discrete orientation
===================== */
const COLORS = {
  white:[240,240,250],
  yellow:[255,240,60],
  green:[60,220,140],
  blue:[60,140,220],
  red:[255,60,60],
  orange:[255,165,0],
};

function freshOrientation(){
  return {
    top:'white', bottom:'yellow',
    north:'green', south:'blue',
    east:'red', west:'orange'
  };
}

const ROLL = {
  north:o=>({ top:o.south,bottom:o.north,north:o.top,south:o.bottom,east:o.east,west:o.west }),
  south:o=>({ top:o.north,bottom:o.south,north:o.bottom,south:o.top,east:o.east,west:o.west }),
  east:o =>({ top:o.west,bottom:o.east,east:o.top,west:o.bottom,north:o.north,south:o.south }),
  west:o =>({ top:o.east,bottom:o.west,east:o.bottom,west:o.top,north:o.north,south:o.south }),
};

/* =====================
   Drawing
===================== */
function quad(p,a,b,c,d,color){
  p.noStroke();
  p.fill(...COLORS[color]);
  p.beginShape();
  p.vertex(...a); p.vertex(...b);
  p.vertex(...c); p.vertex(...d);
  p.endShape(p.CLOSE);
}

function drawCube(p,o){
  const h=CUBE/2;
  const p000=[-h,-h,-h], p001=[-h,-h,h], p010=[-h,h,-h], p011=[-h,h,h];
  const p100=[ h,-h,-h], p101=[ h,-h,h], p110=[ h,h,-h], p111=[ h,h,h];

  quad(p,p001,p101,p111,p011,o.top);
  quad(p,p000,p010,p110,p100,o.bottom);
  quad(p,p011,p111,p110,p010,o.south);
  quad(p,p000,p100,p101,p001,o.north);
  quad(p,p101,p100,p110,p111,o.east);
  quad(p,p000,p001,p011,p010,o.west);
}

/* =====================
   State
===================== */
let cube = { x:2, y:2, o:freshOrientation() };
let anim = null;
let dragging=false, dragDX=0, dragDY=0;

/* =====================
   Helpers
===================== */
const inside=(x,y)=>x>=0&&x<GRID&&y>=0&&y<GRID;
const world=(x,y)=>{
  const r=GRID*CELL/2;
  return[-r+CELL/2+x*CELL, -r+CELL/2+y*CELL];
};
const ease = t => t*t*(3-2*t);

function rotationAngles(dir, e){
  const a = -e * Math.PI/2;
  if(dir==='north') return { rx:-a, ry:0 };
  if(dir==='south') return { rx: a, ry:0 };
  if(dir==='east')  return { rx:0, ry:-a };
  if(dir==='west')  return { rx:0, ry: a };
  return { rx:0, ry:0 };
}

/* =====================
   p5
===================== */
new p5(p=>{
  p.setup=()=>p.createCanvas(innerWidth,innerHeight,p.WEBGL);

  p.draw=()=>{
    p.background(20);

    // grid
    const r=GRID*CELL/2;
    p.stroke(150); p.noFill();
    for(let i=0;i<=GRID;i++){
      const t=-r+i*CELL;
      p.line(t,-r,0,t,r,0);
      p.line(-r,t,0,r,t,0);
    }

    // draw snapped cube (always safe)
    if(!anim || anim.newCube){
      const [cx,cy]=world(cube.x,cube.y);
      p.push();
      p.translate(cx,cy,CUBE/2);
      drawCube(p,cube.o);
      p.pop();
    }

    // draw animated cube
    if(anim){
      const raw = Math.min((p.millis()-anim.t0)/ANIM_MS, 1);
      const e = ease(raw);

      const x = p.lerp(anim.x0, anim.x1, e);
      const y = p.lerp(anim.y0, anim.y1, e);
      const ang = rotationAngles(anim.dir, e);

      const [cx,cy]=world(x,y);
      p.push();
      p.translate(cx,cy,CUBE/2);
      if(ang.rx) p.rotateX(ang.rx);
      if(ang.ry) p.rotateY(ang.ry);
      drawCube(p,anim.oldCube.o);
      p.pop();

      // spawn snapped cube just before the end
      if(raw >= 0.95 && !anim.newCube){
        anim.newCube = {
          x: anim.x1,
          y: anim.y1,
          o: ROLL[anim.dir](anim.oldCube.o)
        };
        cube = anim.newCube;
      }

      // cleanup
      if(raw >= 1){
        anim = null;
      }
    }
  };

  p.mousePressed=()=>{
    dragging=true;
    dragDX=dragDY=0;
  };

  p.mouseDragged=()=>{
    if(dragging){
      dragDX+=p.movedX;
      dragDY+=p.movedY;
    }
  };

  p.mouseReleased=()=>{
    dragging=false;
    if(anim || Math.hypot(dragDX,dragDY) < DRAG_THRESHOLD) return;

    const dir =
      Math.abs(dragDX)>Math.abs(dragDY)
        ? (dragDX>0?'east':'west')
        : (dragDY>0?'south':'north');

    const nx=cube.x+(dir==='east')-(dir==='west');
    const ny=cube.y+(dir==='south')-(dir==='north');
    if(!inside(nx,ny)) return;

    anim = {
      dir,
      t0:p.millis(),
      x0:cube.x, y0:cube.y,
      x1:nx, y1:ny,
      oldCube: { x:cube.x, y:cube.y, o:cube.o },
      newCube: null
    };
  };

  p.windowResized=()=>p.resizeCanvas(innerWidth,innerHeight);
});
</script>
</body>
</html>