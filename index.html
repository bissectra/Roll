<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Cube Roll – Correct Local Quaternion Axes (NS sign fixed)</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
<style>
html,body { margin:0; background:#111; overflow:hidden; }
</style>
</head>
<body>
<script>
/* =======================
   Parameters
======================= */
const GRID = 5;
const CELL = 80;
const CUBE = CELL * 0.85;
const DRAG_THRESHOLD = 20;
const ANIM_MS = 220;

/* =======================
   Colors
======================= */
const COLORS = {
  red:[255,60,60],
  green:[60,220,140],
  blue:[60,140,220],
  yellow:[255,240,60],
  white:[240,240,250],
  orange:[255,165,0],
};

/* =======================
   Discrete orientation
======================= */
const freshOrientation = () => ({
  top:'white', bottom:'yellow',
  north:'green', south:'blue',
  east:'red', west:'orange'
});

const ROLL_MAP = {
  north:o=>({top:o.south,bottom:o.north,north:o.top,south:o.bottom,east:o.east,west:o.west}),
  south:o=>({top:o.north,bottom:o.south,north:o.bottom,south:o.top,east:o.east,west:o.west}),
  east: o=>({top:o.west,bottom:o.east,east:o.top,west:o.bottom,north:o.north,south:o.south}),
  west: o=>({top:o.east,bottom:o.west,east:o.bottom,west:o.top,north:o.north,south:o.south}),
};

/* =======================
   Quaternion math
======================= */
const quat = (w,x,y,z)=>({w,x,y,z});

const quatMul = (a,b)=>({
  w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
  x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
  y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
  z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,
});

const quatFromAxisAngle = (ax,ay,az,angle)=>{
  const h = angle/2;
  const s = Math.sin(h);
  return quat(Math.cos(h), ax*s, ay*s, az*s);
};

function quatApply(p,q){
  const angle = 2*Math.acos(q.w);
  const s = Math.sin(angle/2);
  if (s < 1e-6) return;
  p.rotate(angle, [q.x/s, q.y/s, q.z/s]);
}

/* =======================
   Orientation → quaternion
======================= */
const FACE_DIR = {
  white:[0,0,1],  yellow:[0,0,-1],
  blue:[0,1,0],   green:[0,-1,0],
  red:[1,0,0],    orange:[-1,0,0],
};

function quatFromRotationMatrix(m00,m01,m02,m10,m11,m12,m20,m21,m22){
  const tr = m00+m11+m22;
  let w,x,y,z;
  if (tr > 0) {
    const s = Math.sqrt(tr+1)*2;
    w = 0.25*s;
    x = (m21-m12)/s;
    y = (m02-m20)/s;
    z = (m10-m01)/s;
  } else if (m00 > m11 && m00 > m22) {
    const s = Math.sqrt(1+m00-m11-m22)*2;
    w = (m21-m12)/s;
    x = 0.25*s;
    y = (m01+m10)/s;
    z = (m02+m20)/s;
  } else if (m11 > m22) {
    const s = Math.sqrt(1+m11-m00-m22)*2;
    w = (m02-m20)/s;
    x = (m01+m10)/s;
    y = 0.25*s;
    z = (m12+m21)/s;
  } else {
    const s = Math.sqrt(1+m22-m00-m11)*2;
    w = (m10-m01)/s;
    x = (m02+m20)/s;
    y = (m12+m21)/s;
    z = 0.25*s;
  }
  return quat(w,x,y,z);
}

function quatFromOrientation(o){
  // local +X = east face of base cube
  // local +Y = south face of base cube
  // local +Z = top face of base cube
  const ex = FACE_DIR[o.east];
  const ey = FACE_DIR[o.south];
  const ez = FACE_DIR[o.top];
  return quatFromRotationMatrix(
    ex[0], ey[0], ez[0],
    ex[1], ey[1], ez[1],
    ex[2], ey[2], ez[2]
  );
}

/* =======================
   Drawing
======================= */
function quad(p,a,b,c,d,col){
  p.noStroke();
  p.fill(...COLORS[col]);
  p.beginShape();
  p.vertex(...a); p.vertex(...b);
  p.vertex(...c); p.vertex(...d);
  p.endShape(p.CLOSE);
}

const BASE = freshOrientation();

function drawBaseCube(p){
  const h = CUBE/2;
  const p000=[-h,-h,-h], p001=[-h,-h, h];
  const p010=[-h, h,-h], p011=[-h, h, h];
  const p100=[ h,-h,-h], p101=[ h,-h, h];
  const p110=[ h, h,-h], p111=[ h, h, h];

  quad(p,p001,p101,p111,p011,BASE.top);
  quad(p,p000,p010,p110,p100,BASE.bottom);
  quad(p,p011,p111,p110,p010,BASE.south);
  quad(p,p000,p100,p101,p001,BASE.north);
  quad(p,p101,p100,p110,p111,BASE.east);
  quad(p,p000,p001,p011,p010,BASE.west);
}

/* =======================
   State
======================= */
let cube = { x:2, y:2, o:freshOrientation() };
let anim = null;
let dragDX=0, dragDY=0, dragging=false;

/* =======================
   Helpers
======================= */
const inside = (x,y)=>x>=0&&x<GRID&&y>=0&&y<GRID;
const world = (x,y)=>{
  const r = GRID*CELL/2;
  return [-r + CELL/2 + x*CELL, -r + CELL/2 + y*CELL];
};

/* LOCAL axes (correct) */
const ROLL_AXIS = {
  north:[1,0,0],
  south:[1,0,0],
  east: [0,1,0],
  west: [0,1,0],
};

/* ✅ FIX: swap NS signs */
const ROLL_SIGN = {
  north: -1,
  south:  1,
  east:  -1,
  west:   1,
};

/* =======================
   p5
======================= */
new p5(p=>{
  p.setup=()=>p.createCanvas(innerWidth,innerHeight,p.WEBGL);

  p.draw=()=>{
    p.background(20);

    // grid
    const r = GRID*CELL/2;
    p.stroke(160); p.noFill();
    for(let i=0;i<=GRID;i++){
      const t=-r+i*CELL;
      p.line(t,-r,0,t,r,0);
      p.line(-r,t,0,r,t,0);
    }

    let x=cube.x, y=cube.y;
    const qStart = quatFromOrientation(cube.o);
    let q = qStart;

    if(anim){
      const t = Math.min((p.millis()-anim.t0)/ANIM_MS,1);
      const e = t*t*(3-2*t);

      x = p.lerp(anim.x0, anim.x1, e);
      y = p.lerp(anim.y0, anim.y1, e);

      const ang = e * Math.PI/2 * ROLL_SIGN[anim.dir];
      const ax = ROLL_AXIS[anim.dir];
      const qRoll = quatFromAxisAngle(ax[0],ax[1],ax[2],ang);

      // local/body rotation:
      q = quatMul(qStart, qRoll);

      if(t>=1){
        cube.x = anim.x1;
        cube.y = anim.y1;
        cube.o = anim.o1;
        anim = null;
      }
    }

    const [cx,cy] = world(x,y);
    p.push();
    p.translate(cx,cy,CUBE/2);
    quatApply(p,q);
    drawBaseCube(p);
    p.pop();
  };

  p.mousePressed=()=>{ dragging=true; dragDX=dragDY=0; };
  p.mouseDragged=()=>{ if(dragging){ dragDX+=p.movedX; dragDY+=p.movedY; } };
  p.mouseReleased=()=>{
    dragging=false;
    if(anim || Math.hypot(dragDX,dragDY) < DRAG_THRESHOLD) return;

    const dir =
      Math.abs(dragDX) > Math.abs(dragDY)
        ? (dragDX>0 ? 'east' : 'west')
        : (dragDY>0 ? 'south' : 'north');

    const nx = cube.x + (dir==='east') - (dir==='west');
    const ny = cube.y + (dir==='south') - (dir==='north');
    if(!inside(nx,ny)) return;

    anim = {
      dir,
      x0:cube.x, y0:cube.y,
      x1:nx, y1:ny,
      o1:ROLL_MAP[dir](cube.o),
      t0:p.millis()
    };
  };

  p.windowResized=()=>p.resizeCanvas(innerWidth, innerHeight);
});
</script>
</body>
</html>