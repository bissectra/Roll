<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>CubeRoll â€“ Minimal</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
<style>
html,body{margin:0;background:#111;color:#eee;font-family:sans-serif}
#hint{position:fixed;bottom:10px;left:10px;opacity:.7}
</style>
</head>
<body>
<div id="hint">Drag to roll</div>

<script>
/* ===== parameters ===== */
const GRID = 5;
const CELL = 60;
const CUBE = CELL * 0.9;
const DRAG_THRESHOLD = 25;

/* ===== colors ===== */
const COLORS = {
  red:[255,60,60], green:[60,220,140], blue:[60,140,220],
  yellow:[255,240,60], white:[240,240,250], orange:[255,165,0]
};

/* ===== orientation roll maps ===== */
const ROLL = {
  north:o=>({top:o.south,bottom:o.bottom,north:o.north,south:o.top,east:o.east,west:o.west}),
  south:o=>({top:o.north,bottom:o.bottom,north:o.top,south:o.south,east:o.east,west:o.west}),
  east: o=>({top:o.west,bottom:o.bottom,west:o.top,east:o.east,north:o.north,south:o.south}),
  west: o=>({top:o.east,bottom:o.bottom,east:o.top,west:o.west,north:o.north,south:o.south})
};

/* ===== game state ===== */
let cube = {
  x:2,y:2,
  o:{top:'white',bottom:'yellow',north:'green',south:'blue',east:'red',west:'orange'}
};

let goals = [
  {x:1,y:1,color:'red'},
  {x:3,y:3,color:'green'}
];

/* ===== drag tracking ===== */
let dragging = false;
let dragDX = 0, dragDY = 0;

/* ===== helpers ===== */
const world = (x,y)=>{
  const r = GRID * CELL / 2;
  return [-r + CELL/2 + x*CELL, -r + CELL/2 + y*CELL];
};

function drawCube(p,x,y,o){
  const [cx,cy] = world(x,y);
  const h = CUBE/2;
  p.push();
  p.translate(cx,cy,h);
  p.noStroke();

  const face = (dx,dy,dz,c)=>{
    p.fill(...COLORS[c]);
    p.beginShape();
    p.vertex( dx*h, dy*h, dz*h);
    p.vertex( dx*h,-dy*h, dz*h);
    p.vertex(-dx*h,-dy*h, dz*h);
    p.vertex(-dx*h, dy*h, dz*h);
    p.endShape(p.CLOSE);
  };

  face(0,0, 1,o.top);
  face(0,0,-1,o.bottom);
  face(0,1, 0,o.north);
  face(0,-1,0,o.south);
  face(1,0, 0,o.east);
  face(-1,0,0,o.west);
  p.pop();
}

/* ===== p5 ===== */
new p5(p=>{
  p.setup = ()=>p.createCanvas(p.windowWidth,p.windowHeight,p.WEBGL);

  p.draw = ()=>{
    p.background(16);
    p.lights();

    const r = GRID * CELL / 2;
    p.stroke(255,80); p.noFill();
    for(let i=0;i<=GRID;i++){
      const t = -r + i*CELL;
      p.line(t,-r,0,t,r,0);
      p.line(-r,t,0,r,t,0);
    }

    goals.forEach(g=>{
      const [x,y] = world(g.x,g.y);
      p.push();
      p.translate(x,y,0);
      p.noStroke();
      p.fill(...COLORS[g.color]);
      p.rectMode(p.CENTER);
      p.rect(0,0,CELL*0.6,CELL*0.6);
      p.pop();
    });

    drawCube(p,cube.x,cube.y,cube.o);

    if(dragging){
      p.resetMatrix();
      p.translate(-p.width/2,-p.height/2);
      p.stroke(255);
      p.line(p.mouseX-dragDX,p.mouseY-dragDY,p.mouseX,p.mouseY);
    }

    const solved = goals.every(g =>
      g.x===cube.x && g.y===cube.y && cube.o.top===g.color
    );

    if(solved){
      p.resetMatrix();
      p.translate(-p.width/2,-p.height/2);
      p.fill(255); p.noStroke(); p.textSize(32);
      p.text("Solved!",20,40);
    }
  };

  p.mousePressed = ()=>{
    dragging = true;
    dragDX = dragDY = 0;
  };

  p.mouseDragged = ()=>{
    if(!dragging) return;
    dragDX += p.movedX;
    dragDY += p.movedY;
  };

  p.mouseReleased = ()=>{
    if(!dragging) return;
    dragging = false;

    if(Math.hypot(dragDX,dragDY) < DRAG_THRESHOLD) return;

    let dir =
      Math.abs(dragDX) > Math.abs(dragDY)
        ? (dragDX>0?'east':'west')
        : (dragDY>0?'south':'north');

    const nx = cube.x + (dir==='east') - (dir==='west');
    const ny = cube.y + (dir==='south') - (dir==='north');
    if(nx<0||nx>=GRID||ny<0||ny>=GRID) return;

    cube.x = nx;
    cube.y = ny;
    cube.o = ROLL[dir](cube.o);
  };

  p.windowResized = ()=>p.resizeCanvas(p.windowWidth,p.windowHeight);
});
</script>
</body>
</html>